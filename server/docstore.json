[[["1b81271f-23e9-4a33-90bc-4d422a831285",{"pageContent":"2.2.2 Non-Persistent and Persistent Connections\r\nIn many Internet applications, the client and server communicate for an extended\r\nperiod of time, with the client making a series of requests and the server responding to\r\neach of the requests. Depending on the application and on how the application is being\r\nused, the series of requests may be made back-to-back, periodically at regular intervals,\r\nor intermittently. When this client-server interaction is taking place over TCP, the application developer needs to make an important decision––should each request/response\r\npair be sent over a separate TCP connection, or should all of the requests and their corresponding responses be sent over the same TCP connection? In the former approach,\r\nthe application is said to use non-persistent connections; and in the latter approach,\r\npersistent connections. To gain a deep understanding of this design issue, let’s examine the advantages and disadvantages of persistent connections in the context of a specific application, namely, HTTP, which can use both non-persistent connections and\r\npersistent connections. Although HTTP uses persistent connections in its default mode,\r\nHTTP clients and servers can be configured to use non-persistent connections instead.\r\nHTTP with Non-Persistent Connections\r\nLet’s walk through the steps of transferring a Web page from server to client for the\r\ncase of non-persistent connections. Let’s suppose the page consists of a base HTML\r\n100 CHAPTER 2 • APPLICATION LAYER\r\nfile and 10 JPEG images, and that all 11 of these objects reside on the same server.\r\nFurther suppose the URL for the base HTML file is\r\nhttp://www.someSchool.edu/someDepartment/home.index\r\nHere is what happens:\r\n1. The HTTP client process initiates a TCP connection to the server\r\nwww.someSchool.edu on port number 80, which is the default port number for HTTP. Associated with the TCP connection, there will be a socket at the\r\nclient and a socket at the server.\r\n2. The HTTP client sends an HTTP request message to the server via its socket. The\r\nrequest message includes the path name /someDepartment/home.index.\r\n(We will discuss HTTP messages in some detail below.)\r\n3. The HTTP server process receives the request message via its socket, retrieves\r\nthe object /someDepartment/home.index from its storage (RAM or\r\ndisk), encapsulates the object in an HTTP response message, and sends the\r\nresponse message to the client via its socket.\r\n4. The HTTP server process tells TCP to close the TCP connection. (But TCP\r\ndoesn’t actually terminate the connection until it knows for sure that the client\r\nhas received the response message intact.)\r\n5. The HTTP client receives the response message. The TCP connection terminates. The message indicates that the encapsulated object is an HTML file. The\r\nclient extracts the file from the response message, examines the HTML file,\r\nand finds references to the 10 JPEG objects.\r\n6. The first four steps are then repeated for each of the referenced JPEG objects.\r\nAs the browser receives the Web page, it displays the page to the user. Two different browsers may interpret (that is, display to the user) a Web page in somewhat different ways. HTTP has nothing to do with how a Web page is interpreted by a client. The\r\nHTTP specifications ([RFC 1945] and [RFC 2616]) define only the communication\r\nprotocol between the client HTTP program and the server HTTP program.\r\nThe steps above illustrate the use of non-persistent connections, where each TCP\r\nconnection is closed after the server sends the object—the connection does not persist\r\nfor other objects. Note that each TCP connection transports exactly one request message and one response message. Thus, in this example, when a user requests the Web\r\npage, 11 TCP connections are generated.\r\nIn the steps described above, we were intentionally vague about whether the\r\nclient obtains the 10 JPEGs over 10 serial TCP connections, or whether some of the\r\nJPEGs are obtained over parallel TCP connections. Indeed, users can configure\r\nmodern browsers to control the degree of parallelism. In their default modes, most\r\nbrowsers open 5 to 10 parallel TCP connections, and each of these connections handles one request-response transaction. If the user prefers, the maximum number of\r\n2.2 • THE WEB AND HTTP 101\r\nparallel connections can be set to one, in which case the 10 connections are established serially. As we’ll see in the next chapter, the use of parallel connections shortens the response time.\r\nBefore continuing, let’s do a back-of-the-envelope calculation to estimate the\r\namount of time that elapses from when a client requests the base HTML file until\r\nthe entire file is received by the client. To this end, we define the round-trip time\r\n(RTT), which is the time it takes for a small packet to travel from client to server\r\nand then back to the client. The RTT includes packet-propagation delays, packetqueuing delays in intermediate routers and switches, and packet-processing\r\ndelays. (These delays were discussed in Section 1.4.) Now consider what happens\r\nwhen a user clicks on a hyperlink. As shown in Figure 2.7, this causes the browser\r\nto initiate a TCP connection between the browser and the Web server; this\r\ninvolves a “three-way handshake”—the client sends a small TCP segment to the\r\nserver, the server acknowledges and responds with a small TCP segment, and,\r\nfinally, the client acknowledges back to the server. The first two parts of the threeway handshake take one RTT. After completing the first two parts of the handshake, the client sends the HTTP request message combined with the third part of\r\n102 CHAPTER 2 • APPLICATION LAYER\r\nTime\r\nat client\r\nTime\r\nat server\r\nInitiate TCP\r\nconnection\r\nRTT\r\nRequest file\r\nRTT\r\nEntire file received\r\nTime to transmit file\r\nFigure 2.7  Back-of-the-envelope calculation for the time needed to\r\nrequest and receive an HTML file\r\nthe three-way handshake (the acknowledgment) into the TCP connection. Once\r\nthe request message arrives at the server, the server sends the HTML file into the\r\nTCP connection. This HTTP request/response eats up another RTT. Thus, roughly,\r\nthe total response time is two RTTs plus the transmission time at the server of the\r\nHTML file.\r\nHTTP with Persistent Connections\r\nNon-persistent connections have some shortcomings. First, a brand-new connection must be established and maintained for each requested object. For each of\r\nthese connections, TCP buffers must be allocated and TCP variables must be kept\r\nin both the client and server. This can place a significant burden on the Web server,\r\nwhich may be serving requests from hundreds of different clients simultaneously.\r\nSecond, as we just described, each object suffers a delivery delay of two RTTs—\r\none RTT to establish the TCP connection and one RTT to request and receive an\r\nobject.\r\nWith persistent connections, the server leaves the TCP connection open after\r\nsending a response. Subsequent requests and responses between the same client and\r\nserver can be sent over the same connection. In particular, an entire Web page (in\r\nthe example above, the base HTML file and the 10 images) can be sent over a single\r\npersistent TCP connection. Moreover, multiple Web pages residing on the same\r\nserver can be sent from the server to the same client over a single persistent TCP\r\nconnection. These requests for objects can be made back-to-back, without waiting\r\nfor replies to pending requests (pipelining). Typically, the HTTP server closes a connection when it isn’t used for a certain time (a configurable timeout interval). When\r\nthe server receives the back-to-back requests, it sends the objects back-to-back. The\r\ndefault mode of HTTP uses persistent connections with pipelining. We’ll quantitatively compare the performance of non-persistent and persistent connections in the\r\nhomework problems of Chapters 2 and 3. You are also encouraged to see [Heidemann 1997; Nielsen 1997].\r\n2.2.3 HTTP Message Format\r\nThe HTTP specifications [RFC 1945; RFC 2616] include the definitions of the\r\nHTTP message formats. There are two types of HTTP messages, request messages\r\nand response messages, both of which are discussed below.\r\nHTTP Request Message\r\nBelow we provide a typical HTTP request message:\r\nGET /somedir/page.html HTTP/1.1\r\nHost: www.someschool.edu\r\n2.2 • THE WEB AND HTTP 103\r\nConnection: close\r\nUser-agent: Mozilla/5.0\r\nAccept-language: fr\r\nWe can learn a lot by taking a close look at this simple request message. First of\r\nall, we see that the message is written in ordinary ASCII text, so that your ordinary\r\ncomputer-literate human being can read it. Second, we see that the message consists\r\nof five lines, each followed by a carriage return and a line feed. The last line is followed by an additional carriage return and line feed. Although this particular request\r\nmessage has five lines, a request message can have many more lines or as few as\r\none line. The first line of an HTTP request message is called the request line; the\r\nsubsequent lines are called the header lines. The request line has three fields: the\r\nmethod field, the URL field, and the HTTP version field. The method field can take\r\non several different values, including GET, POST, HEAD, PUT, and DELETE.\r\nThe great majority of HTTP request messages use the GET method. The GET\r\nmethod is used when the browser requests an object, with the requested object identified in the URL field. In this example, the browser is requesting the object\r\n/somedir/page.html. The version is self-explanatory; in this example, the\r\nbrowser implements version HTTP/1.1.\r\nNow let’s look at the header lines in the example. The header line Host:\r\nwww.someschool.edu specifies the host on which the object resides. You might\r\nthink that this header line is unnecessary, as there is already a TCP connection in\r\nplace to the host. But, as we’ll see in Section 2.2.5, the information provided by the\r\nhost header line is required by Web proxy caches. By including the Connection:\r\nclose header line, the browser is telling the server that it doesn’t want to bother\r\nwith persistent connections; it wants the server to close the connection after sending\r\nthe requested object. The User-agent: header line specifies the user agent, that\r\nis, the browser type that is making the request to the server. Here the user agent is\r\nMozilla/5.0, a Firefox browser. This header line is useful because the server can\r\nactually send different versions of the same object to different types of user agents.\r\n(Each of the versions is addressed by the same URL.) Finally, the Acceptlanguage: header indicates that the user prefers to receive a French version of\r\nthe object, if such an object exists on the server; otherwise, the server should send\r\nits default version. The Accept-language: header is just one of many content\r\nnegotiation headers available in HTTP.\r\nHaving looked at an example, let’s now look at the general format of a request\r\nmessage, as shown in Figure 2.8. We see that the general format closely follows our\r\nearlier example. You may have noticed, however, that after the header lines (and the\r\nadditional carriage return and line feed) there is an “entity body.” The entity body is\r\nempty with the GET method, but is used with the POST method. An HTTP client\r\noften uses the POST method when the user fills out a form—for example, when a\r\nuser provides search words to a search engine. With a POST message, the user is still\r\nrequesting a Web page from the server, but the specific contents of the Web page\r\n104 CHAPTER 2 • APPLICATION LAYER\r\ndepend on what the user entered into the form fields. If the value of the method field\r\nis POST, then the entity body contains what the user entered into the form fields.\r\nWe would be remiss if we didn’t mention that a request generated with a form\r\ndoes not necessarily use the POST method. Instead, HTML forms often use the GET\r\nmethod and include the inputted data (in the form fields) in the requested URL. For\r\nexample, if a form uses the GET method, has two fields, and the inputs to the two\r\nfields are monkeys and bananas, then the URL will have the structure\r\nwww.somesite.com/animalsearch?monkeys&bananas. In your day-today Web surfing, you have probably noticed extended URLs of this sort.\r\nThe HEAD method is similar to the GET method. When a server receives a\r\nrequest with the HEAD method, it responds with an HTTP message but it leaves out\r\nthe requested object. Application developers often use the HEAD method for debugging. The PUT method is often used in conjunction with Web publishing tools. It\r\nallows a user to upload an object to a specific path (directory) on a specific Web\r\nserver. The PUT method is also used by applications that need to upload objects to\r\nWeb servers. The DELETE method allows a user, or an application, to delete an\r\nobject on a Web server.\r\nHTTP Response Message\r\nBelow we provide a typical HTTP response message. This response message could\r\nbe the response to the example request message just discussed.\r\nHTTP/1.1 200 OK\r\nConnection: close\r\n2.2 • THE WEB AND HTTP 105\r\nmethod sp sp cr lf\r\nheader field name: cr lf\r\nHeader lines\r\nBlank line\r\nEntity body\r\nRequest line\r\nsp value\r\ncr lf\r\ncr lf\r\nheader field name: value sp\r\nURL Version\r\nFigure 2.8  General format of an HTTP request message\r\nDate: Tue, 09 Aug 2011 15:44:04 GMT\r\nServer: Apache/2.2.3 (CentOS)\r\nLast-Modified: Tue, 09 Aug 2011 15:11:03 GMT\r\nContent-Length: 6821\r\nContent-Type: text/html\r\n(data data data data data ...)\r\nLet’s take a careful look at this response message. It has three sections: an initial status line, six header lines, and then the entity body. The entity body is the\r\nmeat of the message—it contains the requested object itself (represented by data\r\ndata data data data ...). The status line has three fields: the protocol version field, a status code, and a corresponding status message. In this example, the\r\nstatus line indicates that the server is using HTTP/1.1 and that everything is OK\r\n(that is, the server has found, and is sending, the requested object).\r\nNow let’s look at the header lines. The server uses the Connection: close\r\nheader line to tell the client that it is going to close the TCP connection after sending\r\nthe message. The Date: header line indicates the time and date when the HTTP\r\nresponse was created and sent by the server. Note that this is not the time when the\r\nobject was created or last modified; it is the time when the server retrieves the\r\nobject from its file system, inserts the object into the response message, and sends\r\nthe response message. The Server: header line indicates that the message was generated by an Apache Web server; it is analogous to the User-agent: header line\r\nin the HTTP request message. The Last-Modified: header line indicates the\r\ntime and date when the object was created or last modified. The Last-Modified:\r\nheader, which we will soon cover in more detail, is critical for object caching, both in\r\nthe local client and in network cache servers (also known as proxy servers). The\r\nContent-Length: header line indicates the number of bytes in the object being\r\nsent. The Content-Type: header line indicates that the object in the entity body is\r\nHTML text. (The object type is officially indicated by the Content-Type: header\r\nand not by the file extension.)\r\nHaving looked at an example, let’s now examine the general format of a\r\nresponse message, which is shown in Figure 2.9. This general format of the response\r\nmessage matches the previous example of a response message. Let’s say a few additional words about status codes and their phrases. The status code and associated\r\nphrase indicate the result of the request. Some common status codes and associated\r\nphrases include:\r\n• 200 OK: Request succeeded and the information is returned in the response.\r\n• 301 Moved Permanently: Requested object has been permanently moved;\r\nthe new URL is specified in Location: header of the response message. The\r\nclient software will automatically retrieve the new URL.\r\n106 CHAPTER 2 • APPLICATION LAYER\r\n• 400 Bad Request: This is a generic error code indicating that the request\r\ncould not be understood by the server.\r\n• 404 Not Found: The requested document does not exist on this server.\r\n• 505 HTTP Version Not Supported: The requested HTTP protocol\r\nversion is not supported by the server.","metadata":{"source":"./data.txt","loc":{"lines":{"from":1,"to":222}}}}]],{"0":"1b81271f-23e9-4a33-90bc-4d422a831285"}]